\chapter{Expression Templates}
Expression Templates is a well known technique implementing a form of delayed evaluation in C++. This idiom allows the compile-time
construction of a type representing the Abstract Syntax Tree (AST) of an arbitrary statement. This is done by overloading functions and
operators so they return a lightweight object which represents the current operation in the AST being built rather than performing any
computation. Once reconstructed, the AST can be transformed into arbitrary code fragments.

Expression templates also solve the \textit{pairwise evaluation problem} associated with classical operator-overloaded (array) expressions
in C++. The problem with pairwise evaluation is that expressions such as
%
\begin{minted}{c++}
  Vector<double> a, b, c, d;
  a = b + c + d;
\end{minted}
%
generate code like this:
%
\begin{minted}{c++}
  double* tmp1 = new double[N];
  for (int i = 0; i < N; ++i)
    tmp1[i] = b[i] + c[1];
  double* tmp2 = new double[N];
  for (int i = 0; i < N; ++i)
    tmp2[i] = tmp1[i] + d[i];
  for (int i = 0; i < N; ++i)
    a[i] = tmp2[i];
  delete[] tmp2;
  delete[] tmp1;
\end{minted}

So we have 4+2 allocations on the heap and 3 loops to evaluate this simple expression. But what we would like to achieve is an evaluation
in one line:
%
\begin{minted}{c++}
  for (int i = 0; i < N; ++i)
    a[i] = b[i] + c[i] + d[i];
\end{minted}
%
that could be much faster.


% =================================================================================================
\section{Domain-Specific Languages}
A \emph{Domain Specific Languages} (DSL) allows description and solution of a problem to be
expressed in the idiom and at the level of abstraction of the problem domain, the
maintainability and quality of code is increased. One of the most popular examples
is \textsf{Matlab} which provides a large selection of toolboxes that allow a direct
expression of highlevel algebraic and numerical constructs in a easy to use imperative
language.

Other examples include a class of finite-element libraries, that try to express the PDE problem
setup in a near-mathematical language, e.g. Fenics project, FreeFem.

\emph{Domain Specific Embedded Languages} (or DSELs) are a sub-class of DSLs that provide a good way to mitigate the
abstraction vs efficiency trade-off. DSELs are languages implemented inside a general-purpose, host language.
DSELs do not require a dedicated compiler or interpreter to be used as they exist inside another general purpose
language. They are usually implemented as a library-like component.

Examples include the finite-element library \textsf{Feel++}, \textsf{LiveV} and also linear algebra
libraries, like \textsf{MTL4}, \textsf{Eigen}, \textsf{Blaze}, \textsf{uBlas}, \textsf{NT$^2$}, \textsf{VexCL}, and many more.
Also libraries in the context of automatic (or symbolic) differentiation, or inteval arithmetic make use of expression templates.

The DSEL approach has advantages over generating a specific external
language: (i) interpreter/compiler construction complexities can be ignored, (ii) libraries can concurrently be used
which is often not the case of specific languages which would have to also develop their own libraries and library
system, (iii) DSELs inherit the capabilities of the host language (e.g. C++).

In all cases, the Domain-Specific Language tries to hide the programming details from the user of a library, and
from the expert in this specific domain. In this sense an expression can be translated to an already implemented and highly specialized
external function (like BLAS library), and it can break down a complex expression into optimal code (\emph{kernels}), making use of loop
unrolling/ vectorization/ parallelization techniques and so on. Some libraries go further and provide a language
that translates into architecture optimized code (e.g. code for GPUs, or high performance computers, Clusters, or
multi-core CPUs, like Intel Phi processor) and generate code that makes use of available instruction sets on the
target CPU.


% =================================================================================================
\section{Expression templates: encoding operations}
The basic idea behind \emph{expression templates} is to implement a DSEL using operator-overloading in C++, where the operator does not
perform the underlying operation directly, but returns a light-weight object, similar to a functor, that represents the operator operation
and can easily be chained with others of these leight-weight operations. Only when explicitly asked for, the operation is evaluated.
This is called \emph{lazy-evaluation}, because the evaluation is shifted to a later point in code, e.g. in the final assignment, or in the
destruction on an object.

\begin{example}
  Consider again the example of the sum of three vectors
  %
  \begin{minted}{c++}
  Vector<double> b, c, d;
  b + c + d;
  \end{minted}
  %
  The underlying operation that needs to be performed on the elements of the vectors, can be represented by
  just one functor:
  \begin{minted}{c++}
  struct Op {
    template <class T>
    T operator()(T b_i, T c_i, T d_i) const {
      return b_i + c_i + d_i;
    }
  };
  \end{minted}
  It returns the sum of the three elements. Now, this functor can be applied in a loop:
  \begin{minted}{c++}
  Vector a;
  for (int i = 0; i < N; ++i)
    a[i] = op(b[i], c[i], d[i]);
  \end{minted}
\end{example}

\begin{example}
  Another example of lazy-evaluation is the composition of functions (functors). Lets assume, we have an abstract class
  representing various (unary) functions, \cpp{Function<ReturnType,ArgumentType>}. We want to compose these function to generate
  a new function, just using operator overloading:
  \begin{minted}{c++}
  Function<double,double> f, g, h;

  double x = 42.0;
  double y = f(x); // evaluation

  auto sum_fgh = f + g + h; // -> new function

  double z = sum_fgh(x); // can be evaluated as well
  assert( z == f(x) + g(x) + h(x) );
  \end{minted}

  Let $f, g:\mathbb{R}\to\mathbb{R}$ be two unary (real-valued) functions. The expression $f+g$ can be understood as a function:
  \[
    f+g:\mathbb{R}\to\mathbb{R},\;x\mapsto(f+g)(x) := f(x) + g(x)
  \]

  Also, more complex expressions with functions can be written, like
  \[
    f^2:\mathbb{R}\to\mathbb{R},\;x\mapsto(f^2)(x) := f(x)^2\,,
  \]
  or
  \[
    sin(g):\mathbb{R}\to\mathbb{R},\;x\mapsto(\sin(g))(x) := \sin(g(x))\,,
  \]
  and even
  \[
    f(g):\mathbb{R}\to\mathbb{R},\;x\mapsto(f(g))(x) := f(g(x))\,.
  \]

  This means, one function applied to another function can generator a new function that has to be understood as point-wise composition. So, the right-hand
  side of the function definition defines whats means the left-hand side.
\end{example}

In the two examples above, the operators, like \cpp{operator+} or \cpp{operator()}, may have different meaning when applied to \cpp{Vector} or \cpp{Function},
and do not perform any operation (on vectors elements) directly, but should just return an object, that behaves like the \cpp{Vector} or \cpp{Function} type
before. This returned object is called an \emph{expression template} and it is a template, since the input can be either the \cpp{Vector} type directly, or
any other expression template build before.


% -------------------------------------------------------------------------------------------------
\subsection{Composition of operations}
To represent the composition of objects of some type (e.g. Vector or Function), we use the technique of composing functors representing the
element-wise or point-wise operation. Composition of more than one object might be represented as an \emph{abstract syntax tree} (AST) where
inner nodes in the tree represent the unary or binary operations, and the leaf nodes represent the data.

\begin{example}
  Consider the vector sum example from above:
  %
  \begin{minted}{c++}
  Vector<double> a, b, c, d;
  a = b + c + d;
  \end{minted}
  %
  This composition of binary plus operators results in an AST:
  %
  \begin{equation}
  \Tree [.= a [.+ [.+ b c ] d ] ]
  \end{equation}
  %
  Each inner node node represents the binary plus operation, to be applied to the result of the lower level branches. The leaf nodes represent the vectors.

  The root of the tree has the special function to initiate the evaluation, here given by the assignment to the target vector \texttt{a}.
  Those operations in the root node will be called \emph{terminal operations} in the following.
\end{example}

Composite operations are given by a composition of elementary operations. They represent a new type that can be used similar to the leaf objects, i.e.
it implements a similar interface.

\begin{example}
  A vVector has implemented the \cpp{operator[]} to evaluate at a given index. We can easily introduce a new type \cpp{VectorPlusExpr}, that represents the sum of
  two vectors:
  \begin{minted}{c++}
  class VectorPlusExpr
  {
    Vector const& a_;
    Vector const& b_;

  public:
    VectorPlusExpr(Vector const& a, Vector const& b)
      : a_(a)
      , b_(b)
    {}

    double operator[](int i) const
    {
      return a_[i] + b_[i];
    }
  };
  \end{minted}

  Although it represents the sum of two vectors, it is difficult to build more complex operations, since we are fixed to vectors. This can be
  solved, by introducing template parameters:
  \begin{minted}{c++}
  template <class A, class B>
  class PlusExpr
  {
    A const& a_;
    B const& b_;

  public:
    PlusExpr(A const& a, B const& b)
      : a_(a)
      , b_(b)
    {}

    double operator[](int i) const
    {
      return a_[i] + b_[i];
    }
  };
  \end{minted}
  %
  The only requirement that we have is that the template types \texttt{A} and \texttt{B} have an \cpp{operator[]}.

  With this, the sum of three vector, can be written as the type \cpp{PlusExpr< PlusExpr< Vector, Vector >, Vector}.
\end{example}


% -------------------------------------------------------------------------------------------------
\subsection{Expressions}
Instead of writing out the element-wise operation, it can be envoded in a functor directly and the composition of the vector can be
parametrized by the input types and the functor type. Sometimes this class-template is called \emph{expression template}, since the
expression is encoded by template parameters.

First, lets consider unary transformations of expressions, i.e. where a unary functor can be applied element-wise (or point-wise).
We call it a \emph{unary expression}:
%
\begin{minted}{c++}
  template <class Functor, class Argument>
  class UnaryExpr
  {
    Functor f_;
    Argument const& a_;

  public:
    UnaryExpr(Functor f, Argument const& a)
      : f_(f)
      , a_(a)
    {}

    // access the i'th element of the expression
    auto operator[](int i) const
    {
      // apply the unary functor element-wise
      return f_( a_[i] );
    }
  };
\end{minted}
%
So, on evaluation we apply the functor to the input value. The class-template must be parametrized with both, the functor and the argument type.

There is also a binary expression, taking a binary functor and two input arguments as template parameters:
%
\begin{minted}{c++}
template <class Functor, class Argument1, class Argument2>
class BinaryExpr
{
  Functor f_;
  Argument1 const& a1_;
  Argument2 const& a2_;

public:
  BinaryExpr(Functor f, Argument1 const& a1, Argument2 const& a2)
    : f_(f)
    , a1_(a1)
    , a2_(a2)
  {}

  // access the i'th element of the expression
  auto operator[](int i) const
  {
    // apply the binary functor element-wise
    return f_( a1_[i], a2_[i] );
  }
};
\end{minted}


These unary and binary expressions can now be used to build an evaluation tree representing a complex expression.

\begin{example}
  For the example of the sum of three vectors, we need the binary operation plus:
  \begin{minted}{c++}
  struct Plus
  {
    template <class T1, class T2>
    auto operator()(T1 const& x, T2 const& y) { return x + y; }
  };
  \end{minted}

  Then, the expressions \cpp{PlusExpr< PlusExpr< Vector, Vector >, Vector >} can now be written using \cpp{BinaryExpr} as
  \begin{minted}{c++}
    BinaryExpr<Plus, BinaryExpr<Plus, Vector, Vector >, Vector >
  \end{minted}

  Instantiating this type is quite complicated, though:
  \begin{minted}{c++}
  Vector a, b, c;
  auto bc_expr = BinaryExpr<Plus, Vector, Vector>{Plus{}, b, c};
  auto bcd_expr = BinaryExpr<Plus, decltype(bc_expr), Vector>{Plus{}, bc_expr, d};

  Vector a;
  for (int i = 0; i < a.size(); ++i)
    a[i] = bcd_expr[i];
  \end{minted}
  %
  This will be simplified in the next chapter.
\end{example}

For the instantiation of expression templates (template and class instantiation) we need some automatic deduction of the
template parameters and automatic composition of the constructor arguments. This can be accomplished by \emph{generator function}.


% =================================================================================================
\section{Generator Funktionen}
To generate a functor from an operation on vectors, or function, we use the concept of generator functions. These functions return
the expression-object introduced above for elementary operations. For the plus operation we would write something like the following
%
\begin{minted}{c++}
  template <typename A, typename B>
  BinaryExpr<Plus, A, B> operator+(A const& a, B const& b)
  {
    return BinaryExpr<Plus, A, B>(Plus{}, a, b);
  }
\end{minted}
%
or a bit shorter:
%
\begin{minted}{c++}
  template <typename A, typename B>
  BinaryExpr<Plus, A, B> operator+(A const& a, B const& b)
  {
    return {Plus{}, a, b};
  }
\end{minted}

Since it is templated with the argument, we can either pass a vector, or another expression to the plus operator. This directly gives
the possibility to combine these operators. Thus, the expression
%
\begin{minted}{c++}
  Vector b, c, d;
  b + c + d;
\end{minted}
%
generates
%
\begin{minted}{c++}
  operator+(operator+(b, c), d)
    = operator+(BinaryExpr<Plus, Vector, Vector>(Plus{}, b,c), d)
    = BinaryExpr<Plus, BinaryExpr<Plus, Vector, Vector>, Vector>
        (Plus{}, BinaryExpr<Plus, Vector, Vector>(b,c), d)
\end{minted}
