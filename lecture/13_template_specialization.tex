\chapter{Template Specialization}
An advantage of generic programming is that we can reuse the same code for multiple types/arguments/parameters. Although this gives us a lot of flexibility
sometimes we want to be more specific, \ie some algorithms require special knowledge about the data types used to allow an efficient implementation. Some
types have additional guarantees (\eg contiguous storage of its data elements) or allow more (efficient) operations (\eg containers with optimized sorting
algorithm directly implemented and not by the generic \cpp{std::sort} function). In such cases is would be advantages to provide a more specialized implementation
of the same algorithm or data-structure without loosing the generic version for the other types.

\begin{example}
  Consider the function \texttt{distance()} returning the Euclidean distance of coordinate vectors.
  %
  \begin{minted}{c++}
  template <typename Point>
  double distance(Point const& a, Point const& b) { // primary template
    double result = 0.0;
    for (int i = 0; i < a.size(); ++i)
      result += (a[i] - b[i]) * (a[i] - b[i]);
    return std::sqrt(result);
  }
  \end{minted}
  %
  If we interpret scalar types also as 1-dimensional coordinate vectors, we might need to provide a specialization of that function
  since the floating point types do not provide an \cpp{operator[]} and do not have a member function \cpp{size()}:
  %
  \begin{minted}{c++}
  template <> // Specialization for floating-point type double
  double distance<double>(double const& a, double const& b) {
    return std::abs(a-b);
  }
  \end{minted}
  %
  Calling (instantiating) the function \texttt{distance} with arguments of type \cpp{double} then results in an instantiation of the more specialized
  function and just returns the absolute difference. This might be more efficient to evaluate than the square-root of the squared value.
\end{example}

\begin{defn}
  The first complete (non-specialized) template definition is called the \emph{primary template}. It has a special meaning in the context of overload resolution.
\end{defn}

Template specialization of function and class templates always start with the keyword \cpp{template <..>} and have the specialized type(s) in angular brackets
directly after the function name or class name, \eg
%
\begin{minted}{c++}
  template <>
  ReturnType functionName<SpecializedType,...>(Arg1 arg1, Arg2 arg2...);

  template <>
  class ClassName<Type1, Type2,...>;
\end{minted}
%
Thereby, all template parameters that are specialized are moved from the template parameter list in \cpp{template<...>} to the specialization parameter list
\cpp{[function|class]Name<...>}. If no template parameters remain in the template parameter list, the specialization is called \emph{full specialization},
otherwise \emph{partial specialization}.

The \emph{primary template} specifies, that a function or class is a template. It is not specialized, but allows any template parameter. It is required to be
declared (not necessarily defined) before any specialization.

Some examples:
\begin{minted}{c++}
  // primary template
  template <class T, class S>
  class MyPoint; // Type T... element type, Type S... index type

  // specialization for element type `double` and index type `int`
  template <>
  class MyPoint<double, int> { ... }; // (a)

  // specialization for any element type but index type `long`
  template <class T>
  class MyPoint<T, long> { ... }; // (b)

  // specialization for element type `M<Point<T,int>' where `T` could be any type
  // and fixed index type `int`
  template <class T>
  class MyPoint< MyPoint<T,int>, int > { ... }; // (c)
\end{minted}
(a) full specialization, (b) and (c) partial template specialization.


% ==============================================================================
\section{Partial Specialization}\label{seq:partial_template_specialization}
If not all template parameters are fixed (specialized) and the template parameter list is not empty, the specialization is called
\emph{partial template specialization}. This is allowed for class templates only! The specialization parameters can depend on some or all remaining
template parameters in the template parameter list, \eg
%
\begin{minted}{c++}
  template <class ValueType>
  struct Rational { ... };

  // specialization for all matrices of type Matrix<T> where T is a free parameter
  template <class T>
  struct Rational<Matrix<T>> { ... };
\end{minted}

Partial template specialization is not allowed for function templates, \eg the following produces an error:
%
\begin{minted}{c++}
  // Declaration of the primary template
  template <typename T, typename Index>
  void foo();

  template <typename T>
  void foo<T, int>() { ... }; // ERROR: Partial template specialization of function templates
\end{minted}

\begin{rem}
  Partial specialization of function templates can be emulated / worked around by using function overloading.
  Therefore, either introduce a helper template, \eg \texttt{id}, and redirect to functions that are overloaded
  on that wrapped type:
  %
  \begin{minted}{c++}
  // helper class template without any members and any data
  template <typename T> struct id {};

  // dispatch function. Function parameter depending on the template parameters
  template <typename T, typename Index>
  void foo_aux(id<T>, id<Index>) { ... } // (1)

  // dispatch function for fixed `index` parameter'
  template <typename T>
  void foo_aux(id<T>, id<int>) { ... } // (2)

  // primary function template. Redirects to dispatch function
  template <typename T, typename Index>
  void foo() { foo_aux(id<T>{}, id<Index>{}); }
  \end{minted}

  The \emph{dispatch function} has the same number of template parameters as the original function, but has function parameters holding
  these wrapped types in a template \cpp{id<...>}. Instantiating this templates does not cost anything and has no overhead. It is just
  used to automatically deduce the template parameters.

  By regular function overloading, one can ``specialize'' on the individual or both template parameters.

  In the code above, the dispatch function (2) is more constrained / more special than the general dispatch function (1).

  \textbf{Note:} Both dispatch functions are primary templates here. No template specialization, but overloading for different template
  signatures.
\end{rem}


% =================================================================================================
\section{Function overloading with Templates}
Combining classical function overloading and template specialization raises the question: which function is more specialized, more constrained than the
other one and thus, which function to call.

Three examples should illustrate, that combining template specialization and overloading is a delicate and complicated situation and should be avoided:

\begin{example}
  Which function is called in the \cpp{main()}?
  \begin{minted}{c++}
  template <class T> void foo(T);  /* (a) */
  template <class T> void foo(T*); /* (b) */
  template <> void foo<int>(int*); /* (c) */

  int main() { int *p; foo(p); }
  \end{minted}
  Here, (b) is an overload of (a) and (c) is a template specialization of (b).

  General procedure:
  \begin{enumerate}
    \item Which of the \emph{primary templates} is the most specialized one? $\Rightarrow$ (a) and (b) are primary templates and (b) is more specialized.
    \item If there are specializations of the selected primary template, choose the most specialized (but viable candidate) of all specialization of this
          primary template. $\Rightarrow$ (c) is specialization of (b), thus choose (c).
  \end{enumerate}
\end{example}

\begin{example}
  Which function is called in the \cpp{main()}?
  \begin{minted}{c++}
  template <class T> void foo(T);  /* (a) */
  template <class T> void foo(T*); /* (b) */
  template <> void foo<int*>(int*);/* (c) */

  int main() { int *p; foo(p); }
  \end{minted}
  The situation is similar to the last example but not exactly equal. Here, (c) is a specialization of (a).

  \begin{enumerate}
    \item (b) is the most specialized primary templates.
    \item Since there is no template specialization of (b), (b) itself is chosen!
  \end{enumerate}
\end{example}

Exact matching non-template functions are always preferred over function templates!

\begin{example}
  Which function is called in the \cpp{main()}?
  \begin{minted}{c++}
  template <class T> void foo(T);  /* (a) */
  template <class T> void foo(T*); /* (b) */
  void foo(int*);                  /* (c) */

  int main() { int *p; foo(p); }
  \end{minted}
  There is a free function (non-template) (c). This is chosen first!
\end{example}

\begin{guideline}{Guideline}
  Do not mix template specialization and function overloading. Prefer function overloading in general.
\end{guideline}

\begin{rem}
  A nice overview and more detailed explanation of the interaction of function template specialization, overloading, argument type deduction and
  argument dependent lookup can be found in the article\begin{itemize}
	  \item \url{https://akrzemi1.wordpress.com/2015/11/19/overload-resolution}
  \end{itemize}
\end{rem}


% -------------------------------------------------------------------------------------------------
\subsection{Basic rules for overload resolution}
\begin{enumerate}
  \item All visible names are collected (involving \emph{argument dependent lookup} (ADL) in the namespaces of the arguments) (\emph{name lookup})
  \item All non-viable functions are erased from that list\begin{itemize}
    \item Number of parameters must match (involving default function parameters)
    \item There must be a sequence of implicit conversions to transform the passed arguments into the function parameter types.
    \item For function templates all template parameters must be deducible (\emph{argument type deduction} -- ATD)
    \item If the replacement of a template parameter by the type derived from ATD would lead to a direct error, this raises a \emph{substitution failure}.
          Candidates involving a substitution failure are simply ignored (a \emph{substitution failure is not an error} -- SFINAE)
    \end{itemize}
  \item A non-template function that is an exact match is the best fitting candidate.
  \item For all primary template the most specialized one is selected (see below).
  \item If there are template specializations of the best fitting primary template, the most specialized (matching) one is selected.
\end{enumerate}

What does it mean to be the \textit{most specialized} template? For two function templates that one is more specialized whose arguments can be inserted into the other function but not vice versa, \eg
%
\begin{minted}{c++}
  template <class S> void foo(S);  // (1)
  template <class T> void foo(T*); // (2)
\end{minted}
%
Every pointer \cpp{T*} is also an arbitrary (non-constrained) type \cpp{S}, but not all types \cpp{S} are pointer types. Thus, (2) is more specialized than (1).
