\section{Namespaces\label{sec:namespace}}
Namespaces allow the programmer to resolve name conflicts. Defining the same name in the same scope results in an error. Namespaces define
named (or unnamed) global scopes.
%
\cppline{namespace NAME { ... }}
%
Symbols declared inside the \cpp{namespace} block are visible only in this block. The \texttt{NAME} of the namespace can be used to explicitly
qualify a function-, class, or variable name inside this namespace. A classical example, that we have seen before, is the standard namespace \cpp{std::}.
The symbol \texttt{::} thereby is the \emph{name-resolution operator} and may be chained to address multiple nested namespaces:
%
\begin{minted}{c++}
  namespace Q {
    namespace V { // original-namespace-definition for V
      void f(); // declaration of Q::V::f
    }
    void V::f() {} // OK
    void V::g() {} // Error: g() is not yet a member of V
    namespace V { // extension-namespace-definition for V
      void g(); // declaration of Q::V::g
    }
  }
  namespace R { // not a enclosing namespace for Q
     void Q::V::g() {} // Error: cannot define Q::V::g inside R
  }
  void Q::V::g() {} // OK: global namespace encloses Q
\end{minted}
%
One can separate declaration and definition of symbols, but only symbols from sub-namespaces can be defined within a namespace. Not just the definition,
but also the access is by the name-resolution operator \texttt{::}.

Namespaces can contain functions, classes, global variables. The outer most surrounding scope is called the \emph{global namespace} and is addressed with
an empty name before the name-resolution operator.

\subsection{\cpp{using} Directive and Declaration}
The statement \cpp{using} allows to import names from another namespace. So, those names can then be used without any namespace qualification, without the
name-resolution operator.

Either, you can import all names from a namespace, by the using-directive \cpp{using namespace NAMESPACE}:
%
\begin{minted}{c++}
namespace scprog {
  void foo() { /*...*/ }
}
int main() {
  using namespace scprog;

  foo(); // Calls foo() from the namespace scprog without scprog::
}
\end{minted}
This is allowed in namespace scope and block scope only. Every name from the import namespace is visible as if it were declared in the nearest enclosing namespace.

This does not import the functions or classes into the current namespace, but just makes the names visible. This is important for name-resolution, e.g.
in function calls.

Note the following:
\begin{itemize}
\item If there is already a local name in the scope declared, the name from the using namespace is hidden by the local name
\item A name from the imported namespace hides a same name in an enclosing namespace of the scope
\item Importing the same name from multiple namespaces into a scope results in a compiler error
\item Importing a name that is the same in the global namespace, results in a compiler error
\end{itemize}

\begin{minted}{c++}
#include <iostream>
int foo() { return 1; }      // (1)

namespace scprog1 {
  int foo() { return 2; }    // (2)
}
namespace scprog2 {
  int foo() { return 3; }    // (3)
  int bar() {
    using namespace scprog1;
    return foo();            // OK: calls (3)
  }
}
int main() {
  using namespace scprog2;
  using namespace scprog1;

  std::cout << bar();
  std::cout << foo(); // error: call of overloaded 'foo()' is ambiguous,
                      // candidates: (1), (2) or (3)
}
\end{minted}

\subsubsection{Namenspace alias}
If you have a complicated or multiple enclosed namespaces, you can introduce a new name (an alias) for this namespace in the local scope.
%
\begin{minted}{c++}
namespace Q {
  namespace V {  // sub-namensraum of Q
    void f() {}; // declaration of Q::V::f
  }
}
void g() {
  using R = Q::V; // alias for the namespace Q::V
  R::f();
}
\end{minted}

\subsubsection{Import of some names from a namespace}
Instead of importing all namespace from a namespace (with \cpp{using namespace N}) one could just declare a local name for a specific name in the namespace:
This allows to not only make a name visible in the current scope, but to actually import that name as if declared in the scope.
%
\begin{minted}{c++}
#include <cmath> // std::sqrt
int main() {
  using std::sqrt;

  sqrt(3.0); // call of std::sqrt without namespace qualification
}
\end{minted}

It is important to understand the difference to the \cpp{using namespace} directive. The \cpp{using} declaration is an actual declaration. So, you can
declare the exact same name twice, but if a name was already declared in the scope and you introduce that same name again (with a different meaning),
the compiler throws an error.

Importing the same name of a function with the same signature from multiple namespace may result in an ambiguous function call.
\begin{minted}{c++}
  namespace B {
    void f(int);
    void f(double);
  }
  namespace C {
    void f(int);
    void f(double);
    void f(char);
  }
  void h() {
    using B::f; // introduces B::f(int), B::f(double)
    using C::f; // introduces C::f(int), C::f(double), and C::f(char)
    f('h');      // calls C::f(char)
    f(1);        // error: B::f(int) or C::f(int)?
    void f(int); // error: f(int) conflicts with C::f(int) and B::f(int)
  }
\end{minted}

\subsection{Argument dependent lookup\label{sec:adl}}
In function call name-lookup, all visible names are inspected. With a using declaration and using directive this list of visible name is extended. But
there is a second way of increasing the list of possible candidates for the overload resolution, by \emph{argument dependent lookup}, or \emph{Koenigs lookup}.

There, the names from another namespace are included in the list of visible functions, of a function parameter is declared in that namespace. So, the
compiler looks also in the namespace of the function arguments.
%
\begin{minted}{c++}
namespace scprog {
  struct A { double x = 1.0; };

  void set(A& a) { a.x = 2.0; }

  A operator+(A, A const&);
}

struct B { double x = 1.0; };

int main()
{
  scprog::A a, b;
  scprog::set(a); // OK: explicit namespace qulification
  set(b);         // OK: ADL

  scprog::operator+(a,b); // OK: explicit namespace qulification
  a + b;                  // OK: ADL

  B x;
  set(x); // ERROR
}
\end{minted}

\begin{example}
For example, to compile \cpp{std::cout << std::endl;}, the compiler performs:
\begin{enumerate}
\item unqualified name lookup for the name \cpp{std}, which finds the declaration of namespace \cpp{std} in the header \cpp{<iostream>}
\item qualified name lookup for the name \cpp{cout}, which finds a variable declaration in the namespace \cpp{std}
\item qualified name lookup for the name \cpp{endl}, which finds a function template declaration in the namespace \cpp{std}
\item argument-dependent lookup for the name \cpp{operator<<}, which finds multiple function template declarations in the namespace \cpp{std}
\end{enumerate}
\end{example}