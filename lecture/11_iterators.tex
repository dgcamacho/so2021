\chapter{Iterators}
A central layer ob abstraction introduced in the C++ standard library are \emph{iterators}. Genrally speaking, iterators are objects allowing the
programmer to traverse the elements of an arbitrary container, without knowing the specific implementation, the data storage or the access pattern to
individual elements of that data-structure. While vectors and arrays may have a direct element access, using the \cpp{operator[]}, lists and trees do
not have such a method, or it might be very expensive to retrieve a specific element in the sequence rather than traversing linearly through the container.

An abstraction that you find in C and that is often that case of an implementation of a data-structure are pointers, pointing to the individual elements or
to the next and previous element in a sequence. But it is not required that containers are implemented with a chain of pointers and constructing the pointer
to an element could be an additional operation. Also, pointers do not give me any information about how a sequence might be traversed and where to find the
next element.

The abstraction that we want to discuss here are \emph{iterators}. They provide similar semantics as regular pointers, but incrementing (or decrementing)
an iterator means pointing to the next (previous) element in the sequence rather than the next position in memory. To allow iterators to be used similar to
pointers, they provide at least the following operation:

\begin{itemize}
  \item Dereferencing with \cpp{operator*}, to access the element the iterator is pointing to
  \item Going to the next element in the sequence, be pre or post increment \cpp{operator++}
  \item Test for equality and inequality by \cpp{operator==} and \cpp{operator!=}.
\end{itemize}

Additionally, iterators are light-weight objects, meaning: they can be copied and returned/passed by value without much overhead. They have a size similar
to a regular pointer.

% =================================================================================================
\section{Iterators of standard library containers}
In the standard library, all containers (\eg \cpp{std::vector}, \cpp{std::list}, \cpp{std::set}) provide at least two functions, \cpp{begin()} and \cpp{end()}
returning an iterator object. Thereby, \cpp{begin()} points to the first element in the sequence and \cpp{end()} is a so called \emph{sentinel} -- an abstraction of a past-the-end iterator.

Using these two iterators, a traversal over the elements of a container can be realized by
%
\begin{minted}{c++}
  #include <iostream>
  #include <vector> // or <list> or <set> or ...
  int main() {
    std::vector<double> v = {...};
    for (auto it = v.begin(); it != v.end(); ++it) {
      // comparison of iterators, increment of the iterator

      std::cout << *it << std::endl;
      // dereferencing of the iterator to get the value
    }
  }
\end{minted}

In standard library containers, the type of iterators is given as a typedef/alias type in the container class, accessible by \cpp{::iterator} or
\cpp{::const_iterator}. A \cpp{const_iterator} can be seen as an abstraction of a pointer to \cpp{const}, whereas an \cpp{iterator} as a pointer to
non-const elements. Thus, one could write out the explicit type in the loop by
%
\begin{minted}{c++}
  for (std::vector<double>::const_iterator it = v.begin(); it != v.end(); ++it)
    std::cout << *it << std::endl;
\end{minted}

The\marginpar{[]\cxx{17}]} end-iterator is not necessarily of the same type as the begin-iterator.

% -------------------------------------------------------------------------------------------------
\subsection{Range-based for-Loops}
Since iterating over a container is essentially always the same, take begin, compare to end, increment; a loop structure that does essentially
those steps is added in \cxx{11}, called \emph{range-for} loop.

The syntax follows the general pattern
\begin{minted}{c++}
  for (range_declaration : range_expression) loop_statement
\end{minted}

\begin{example}
  Consider the following code:
  \begin{minted}{c++}
    std::vector<double> v = ...;
    for (auto const& v_i : v) { std::cout << v_i << std::endl; }
  \end{minted}

  Here, the declaration of of the variable \cpp{auto const& v_i} is the \emph{range\_declaration}, the vector \texttt{v} is a simple
  \emph{range\_expression} (could be anything that generates a range) and \cpp{{std::cout << v_i << std::endl; }} is the \emph{loop\_statement}.
\end{example}

The three parts can be defined as
\begin{description}
  \item[range\_declaration]
    a declaration of a named variable, whose type is the type of the element of the sequence represented by range\_expression, or a reference
    to that type. Often uses the auto specifier for automatic type deduction
  \item[range\_expression]
    any expression that represents a suitable sequence (either an array or an object for which begin and end member functions or free functions
    are defined, see below) or a braced-init-list.
  \item[loop\_statement]
    any statement, typically a compound statement, which is the body of the loop
\end{description}

The generic implementation, \ie what the compiler make out of the range-for loop statement above is the following code:
%
\begin{minted}{c++}
{
  auto && __range = range_expression;
  auto __begin = begin_expr;
  auto __end = end_expr;
  for ( ; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
\end{minted}
where \cpp{begin_expr} (and \cpp{end_expr}) represent the evaluation of \cpp{std::begin(c)} or \cpp{c.begin()} (and \cpp{std::end(c)} or \cpp{c.end()}).


% ==============================================================================
\section{Iterators in generic functions}
In the same way all containers of the standard library can be iterated through as seen above.
This allows to formulate a general programming methodology, implemented in the standard library:

\begin{guideline}{Fundamental Methodology}
  Decouple the Implementation of Data Structures and Algorithms.
\end{guideline}

Each container provides iterators for traversing its content. Each algorithm in the standard library, one the other hand, is implemented in terms
of iterators. In a classical programming style where an algorithm is implemented for a specific data-structure, to implement $m$ algorithms for
$n$ containers one needs
\[
  m\cdot n\text{ implementations}
\]
whereas for algorithms based on iterators, one needs just
\[
  m+n\text{ implementations}
\]

In order to allow iterators to be passed to functions, one needs function templates.

\begin{example}
  Lets have a look at an algorithm of the standard library: \emph{accumulation} of the values in a container.
  \begin{minted}{c++}
  template <typename InputIterator, typename T, typename BinaryFunction>
  T accumulate(InputIterator it, InputIterator end, T init, BinaryFunction op)
  {
    T sum(init);
    for (; it != end; ++it)
      sum = op(sum, *it);
    return sum;
  }
  \end{minted}

  One could think of summing up the values. Then, the \texttt{BinaryFunction} is the function returning
  the sum of two passed arguments and the \texttt{init} value is typically, the neutral value for the plus
  operator (\texttt{0}), \ie where to start the sum from.

  Additionally we get two iterators, describing the range of value we want to sum up. \texttt{it} is thereby the
  first element, and \texttt{end} a position after the last element in the range, so that is it never \textit{equal}
  to an iterator until the iteration is finished.

  A corresponding \cpp{main()} function could look like
  \begin{minted}{c++}
  #include <set>        // std::set
  #include <functional> // std::plus

  int main() {
    std::set<double> v = ...;
    double s = accumulate( v.begin(), v.end(), 0.0, std::plus<double>{} );
  }
  \end{minted}
  %
  So, we can sum up the values of a set, even if they are not stored contiguously in memory.
\end{example}


% -------------------------------------------------------------------------------------------------
\subsection{Iterator categories}
Not all iterators support iteration forward and backward. Some iterators not even support multiple iterations through the same sequence
(after the first traversal, als elements are invalidated), but other containers might even support jumping to an arbitrary position in the
sequence.

To distinguish the different functionality of iterators, the standard library has introduced \emph{iterator categories}:
\begin{description}
  \item[Input iterator]
    Supports only forward iteration at least once through the sequence, and allows to read from the iterators, \ie const dereferencing.
    \begin{itemize}
      \item \cpp{operator++()}
      \item \cpp{operator++(int)}
      \item \cpp{operator*() const}
      \item \cpp{operator->() const}
    \end{itemize}
  \item[Forward Iterator]
    Same as \emph{Input Iterator} but supports multiple iterations through the same sequence.
  \item[Bidirectional Iterator]
    Same as \emph{Forward Iterator} but additionally supports backward iteration:
    \begin{itemize}
      \item \cpp{operator--()}
      \item \cpp{operator--(int)}
    \end{itemize}
  \item[Random Access Iterator]
    Same as \emph{Bidirectional Iterator} but additionally supports arbitrary forward and backward jumps in the sequence:
    \begin{itemize}
      \item \cpp{operator+=(int)}
      \item \cpp{operator-=(int)}
      \item \cpp{operator+(int)}
      \item \cpp{operator-(int)}
      \item \cpp{operator[](int)} increment (or decrement) by arbitrary distance and direct dereferencing
      \item \cpp{operator-(iterator)} distance between two iterators
    \end{itemize}
    and also comparison operators \texttt{<, >, <=, >=}.
  \item[Contiguous Iterator]
    Same as \emph{Random Access Iterator} but additionally guarantees contiguous storage of the elements in the underlying container.
  \item[Output Iterator]
    Supports only forward iteration at least once through the sequence, and allows to write to the elements the iterator is pointing to, \ie mutable dereferencing.
    \begin{itemize}
      \item \cpp{operator++()}
      \item \cpp{operator++(int)}
      \item \cpp{operator*()}
      \item \cpp{operator->()}
    \end{itemize}
\end{description}

The categories introduced above formally describe what an iterator can do and where it can be applied. Some algorithms might require random access to
the elements in the container, like some sorting algorithms, other algorithms are fine with just forward (or even input iterators).
So, we need a way to distinguish different iterator types by its categories.

% -------------------------------------------------------------------------------------------------
\subsection{Iterator traits}
\emph{Traits} are class templates that just provide typedefs/alias types or static values, depending on the template parameters. The special template
\emph{Iterator Traits}, parametrized with an iterator type, thereby provides access to some properties the iterators. A container can provide its
own iterator traits (specialization) to give information about its iterators.

A default implementation of the standard library iterator traits could look like the following:
\begin{minted}{c++}
  template <typename Iter>
  struct iterator_traits {
    using iterator_category = typename Iter::iterator_category;
    using value_type        = typename Iter::value_type;
    using difference_type   = typename Iter::difference_type;
    using pointer           = typename Iter::pointer;
    using reference         = typename Iter::reference;
  };
\end{minted}
%
So, it defines a type representing the \emph{Iterator Category} and some more types, useful for generic algorithms.

Thereby, the type \cpp{pointer} describes the return type of the \cpp{operator->()} of an iterator, the type \cpp{reference} the return type of
\cpp{operator*()}, \cpp{difference_type} is a type that can be used to describe the distance between iterator (typically a signed integer type)
and that is used in the random access increments (not just \cpp{int} as written above).

The category is represented by empty classes, forming a hierarchy that represents the connection between the categories above:
\begin{minted}{c++}
  struct input_iterator_tag { };
  struct output_iterator_tag { };

  struct forward_iterator_tag
    : public input_iterator_tag { };

  struct bidirectional_iterator_tag
    : public forward_iterator_tag { };

  struct random_access_iterator_tag
    : public bidirectional_iterator_tag { };

  struct contiguous_iterator_tag
    : public random_access_iterator_tag { };
\end{minted}

\begin{example}
  The iterator traits can be used to write more generic algorithms. Consider the \emph{accumulate} function from above:
  The return type might be different from the init type, \eg it could be the type of the elements of the sequence:
  %
  \begin{minted}{c++}
  template <typename InputIterator, typename T, typename BinaryFunction>
  auto accumulate(InputIterator it, InputIterator end,
                  T init,
                  BinaryFunction op)
  {
    // extract a type from the iterator traits
    using result_type = typename iterator_traits<InputIterator>::value_type;

    result_type sum(init);
    for (; it != end; ++it)
      sum = op(sum, *it);
    return sum;
  }
  \end{minted}
\end{example}

\begin{rem}(Dependent types)
  Is an associated type (alias type in a class) extracted from a class template instantiated with a template parameter from the surrounding scope,
  we call it a dependent type -- the type depends on template parameters. The additional keyword \cpp{typename} is necessary to tell the compiler
  it is actually a type we are asking for and not a static value or function.
\end{rem}

\begin{example}
  Some algorithms can be improved by knowledge about the iterators. An example is the function \cpp{std::distance} returning the distance
  between two iterator, \ie how many increments are necessary to reach from begin the end iterator.
  %
  \begin{minted}{c++}
  template <class InputIterator>
  typename std::iterator_traits<InputIterator>::difference_type
  distance(InputIterator first, InputIterator last);
  \end{minted}

  The return type is the \cpp{distance_type} associated to the iterator. Two algorithms could be implemented:
  \begin{enumerate}
    \item Iterate from \texttt{first} to \texttt{last} and count the steps.
    \item Directly take the difference between \texttt{first} and \texttt{last} it the iterator is a \emph{Random Access Iterator}
  \end{enumerate}

  Since the difference is only possible if the type supports this operation, we can not simply use an \cpp{if - else} branching. we have
  to implement two function, differing only in the iterator category:
  %
  \newpage
  \begin{minted}{c++}
    template <class InputIterator>
    typename std::iterator_traits<InputIterator>::difference_type
    distance_impl(InputIterator first, InputIterator last, std::input_iterator_tag)
    {
      typename std::iterator_traits<InputIterator>::difference_type d = 0;
      for (; first != last; ++first, ++d) /* no operation */ ;
      return d;
    }

    template <class InputIterator>
    typename std::iterator_traits<InputIterator>::difference_type
    distance_impl(InputIterator first, InputIterator last, std::random_access_iterator_tag)
    {
      return last - first;
    }

    template <class InputIterator>
    typename std::iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last)
    {
      return distance_impl(first, last,
        typename std::iterator_traits<InputIterator>::iterator_category{});
    }
  \end{minted}

  Note, that also forward and bidirectional iterators can be used with these two functions, since they are both
  also input iterators, but not random-access iterators. This can be seen at the class hierarchy of the iterator
  categories.
\end{example}

\begin{guideline}{Technique}
  When specializing generic algorithms, based on properties of the types, \emph{tag dispatching} can be used.
  Thereby, an additional function parameter is introduced that gets passed a simple, typically empty, class,
  called \emph{tag} that represents the specialization.

  If tags are put into a class hierarchy, automatic type conversion to base types can be used together with
  function overloading to allow to specialize for several similar properties.
\end{guideline}


% =================================================================================================
\section{Algorithms}
The C++ standard library implements data-structures and algorithms that can be combined in a flexible way, by using iterators. All container
implementations at least have a method \cpp{begin()} and \cpp{end()} returning iterators to the first and one-past-the-end element.
Algorithms on the other hand are written in terms of iterators for the input and output. Thus, data-structures and algorithms are separated.

Some algorithms of the standard library are introduced here. More can be found in cppreference.com in the \cpp{<algorithm>}%
\footnote{\url{http://en.cppreference.com/w/cpp/algorithm}} and \cpp{<numeric>}\footnote{\url{http://en.cppreference.com/w/cpp/numeric}} headers.


% -------------------------------------------------------------------------------------------------
\subsection{Copy}
Copies the elements of a range\footnote{A \emph{range} denotes a data-structure that can be traversed by a pair of iterators} \cpp{[first, last)}
into another range described by just one output-iterator. Two variants are described here: \cpp{std::copy} and \cpp{std::copy_if}. The latter
only copies those elements fulfilling some condition.
%
\begin{samepage}
\begin{minted}{c++}
  template <class InputIt, class OutputIt>
  OutputIt copy(InputIt first, InputIt last, OutputIt d_first)
  {
    while (first != last) {
      *d_first++ = *first++;
    }
    return d_first;
  }
\end{minted}
\end{samepage}
%
The parameters \texttt{first} and \texttt{last} are iterators of type \texttt{InputIt} and should fulfill the concepts of an input-iterator. The
thirst parameter \texttt{d\_first} is an out-iterator pointing to the first element in the output range. It is of type \texttt{OutputIt}. The
types \texttt{InputIt} and \texttt{OutputIt} are different, allowing to copy from one container in a different one.

The return value of the copy function is again of type \texttt{OutputIt} and thus an iterator into the output range. It points to one-past the element
copied last in the algorithm. Thus, the iterator pair \cpp{[d_first, return_value)} defines a range that has identical elements as the
input range \cpp{[first, last)}.

Since the output range is directly filled using the output iterators, it is expected that this range can store enough elements, \ie the output iterator
can be increment at least as often as the input iterator. It is, on the other hand, not required, that the returned iterator is identical to the end-iterator
of the output range. It is fine to copy less elements that the range could store.

\begin{example}
  Copy elements from a list into a vector:
  %
  \begin{minted}{c++}
  #include <algorithm>
  #include <cassert>
  #include <list>
  #include <vector>

  int main()
  {
    std::list<int> l = {0, 1, 2, 3, 4, 5};
    std::vector<int> v(l.size());
    auto it = std::copy(l.begin(), l.end(), v.begin());

    assert( it == v.end() ); // here, the return iterator points to the end of the vector
  }
  \end{minted}
\end{example}

The second variant of copy, \cpp{std::copy_if}, expects an additional function parameter representing a \emph{unary predicate}, \ie function or functor
taking one parameter and returning a \cpp{bool}:
%
\begin{samepage}
\begin{minted}{c++}
  template <class InputIt, class OutputIt, class UnaryPredicate>
  OutputIt copy_if(InputIt first, InputIt last, OutputIt d_first, UnaryPredicate pred)
  {
    while (first != last) {
      if (pred(*first))
          *d_first++ = *first;
      first++;
    }
    return d_first;
  }
\end{minted}
\end{samepage}
%
The output-iterator is incremented only if the predicate returns \cpp{true}.

\begin{example}
  In the second example, we copy only elements with even values. We use a lambda expression to define the predicate.
  \begin{minted}{c++}
  #include <algorithm>
  #include <cassert>
  #include <list>
  #include <vector>

  int main()
  {
    std::list<int> l = {0, 1, 2, 3, 4, 5};
    std::vector<int> v(l.size());
    auto it = std::copy_if(l.begin(), l.end(), v.begin(),
      [](int i) { return i % 2 == 0; }); // copy only even elements
  }
  \end{minted}
\end{example}


\subsubsection{Backinserter}
The problem with the copy algorithm is that we need to resize the output container before we can copy into it. In case of \cpp{copy_if} we even do
not know how many elements are copied. It would be better, if the algorithm itself could ``resize'' the container to the required size. But we
do not get a container as input, but an iterator. This iterator has no functionality to resize the underlying container. It often does not even has
a reference to the container it points into.

A workaround for this problem is to use a different output-iterator. Not an iterator directly pointing to elements of the output-range, but a special
iterator wrapper that performs on assignment to the dereferenced iterator an \cpp{insert()} or \cpp{push_back()} operation. The corresponding
wrapper type is called \cpp{std::back_insert_iterator} ans is created using the function \cpp{std::back_inserter}.
%
\begin{minted}{c++}
  #include <algorithm>
  #include <cassert>
  #include <iterator> // std::back_inserter
  #include <list>
  #include <vector>

  int main()
  {
    std::list<int> l = {0, 1, 2, 3, 4, 5};
    std::vector<int> v; // an empty vector

    // add new elements to the back of the vector on copy
    auto it = std::copy(l.begin(), l.end(), std::back_inserter(v));

    assert( v.size() == l.size() );
  }
\end{minted}

The class-type \cpp{std::back_insert_iterator} implements the concept of an \cpp{OutputIterator}. Thus, it can be incremented and dereferenced. But, both
methods have a different effect as expected, essentially they do nothing, but, in case of the dereference operator, just return \cpp{*this}, \ie a reference
to itself. Additionally, this iterator implements an assignment \cpp{operator=}, calling \cpp{push_back()} on the wrapped container with the
value given to the assignment operator. (see also the exercise)

Similarly, there is \cpp{std::front_insert_iterator} adding elements to the front of the container by \cpp{push_front()}.


\subsubsection{Ostream-Iterator}
Also some very special output-iterators can be used in combination with \cpp{std::copy()}. An example is the \cpp{std::ostream_iterator}. Instead of
inserting the copied elements into a container, this iterator pushes the element into an output-stream, like \cpp{std::cout}, using the \cpp{operator<<}.

This allows to write all the elements of any container to the output in one line:
\begin{minted}{c++}
  #include <algorithm>
  #include <iostream>
  #include <list>

  int main()
  {
    std::list<int> l = {0, 1, 2, 3, 4, 5};

    // print all elements of the list to the screen
    auto it = std::copy(l.begin(), l.end(), std::ostream_iterator<int>(std::cout, " "));
    std::cout << '\n';
  }
\end{minted}
%
The \cpp{std::ostream_iterator} is a class-template parametrized with the type of the element it has to print to the output-stream. It is
constructed from an output-stream object, like \cpp{std::cout}, \cpp{std::cerr} or \cpp{std::ofstream}, and optionally as second argument
a delimiter separating the printed elements.

The \cpp{std::ostream_iterator} is a model of a \emph{single-pass} \cpp{OutputIterator}, thus can be ``traversed'' only once. In a second traversal
the state of the output-range is already changed and we can not go back.


% -------------------------------------------------------------------------------------------------
\subsection{Fill, generate, and transform}
The following three algorithm applied to a container can change the value of the elements.

The first one, \cpp{std::fill}, sets all elements to the same value:
%
\begin{samepage}
\begin{minted}{c++}
  template <class ForwardIt, class T>
  void fill(ForwardIt first, ForwardIt last, const T& value)
  {
    for (; first != last; ++first) {
      *first = value;
    }
  }
\end{minted}
\end{samepage}

The algorithm \cpp{std::generate} fills a range by values generated by a nullary funktor, called generator:
%
\begin{samepage}
\begin{minted}{c++}
  template <class ForwardIt, class Generator>
  void generate(ForwardIt first, ForwardIt last, Generator g)
  {
    while (first != last) {
      *first++ = g();
    }
  }
\end{minted}
\end{samepage}

The third algorithm, \cpp{std::transform}, applies a unary functor to the elements of a range and assigns the result to an output-iterator:
%
\begin{samepage}
\begin{minted}{c++}
  template <class InputIt, class OutputIt, class UnaryOperation>
  OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op)
  {
    while (first1 != last1) {
      *d_first++ = unary_op(*first1++);
    }
    return d_first;
  }
\end{minted}
\end{samepage}
(There is a second version of \cpp{std::transform} taking two input ranges and one output range by iterators. With this, you could implement element-wise
binary operations, \eg sum of two vectors.)

\begin{example}
  The following example illustrates the interaction of multiple algorithms and data-structures:
  \begin{minted}{c++}
  #include <algorithm>
  #include <cmath>
  #include <list>
  #include <vector>

  int main()
  {
    std::list<int> l(10);
    std::vector<int> v(10);

    // generate input data
    std::fill(l.begin(), l.end(), 2);
    std::generate(v.begin(), v.end(), [](){ return std::rand() % 10; });

    // an empty output sequence
    std::list<int> erg;

    // sum the elements of the input ranges element-wise
    std::transform(l.begin(), l.end(), v.begin(), std::back_inserter(erg),
                  [](int a, int b) { return a+b; });
  }
  \end{minted}
\end{example}


% -------------------------------------------------------------------------------------------------
\subsection{Iota, accumulate, and inner\_product}
The following three algorithms are taken from the standard library \cpp{<numeric>}.

The first algorithm, \cpp{std::iota}, fills a sequence with increasing values, starting from an initial value:
%
\begin{samepage}
\begin{minted}{c++}
  template <class ForwardIt, class T>
  void iota(ForwardIt first, ForwardIt last, T value)
  {
    while(first != last) {
      *first++ = value;
      ++value;
    }
  }
\end{minted}
\end{samepage}
%
The first two parameter define the output-range, while the third parameter gives the start value for the increasing value sequence.

The second algorithm, \cpp{std::accumulate}, we have seen before. It is a reduction algorithm, returning one value as combination of all values in the range.
Thus, it reduces a range to a single value. The default behavior of the accumulate algorithm is to sum up the values of the range, but it is possible to
pass an additional binary functor argument, that defines the actual reduction operation to perform:
%
\begin{samepage}
\begin{minted}{c++}
  template <class InputIt, class T, class BinaryOperation>
  T accumulate(InputIt first, InputIt last, T init, BinaryOperation op)
  {
    for (; first != last; ++first) {
      init = op(init, *first);
    }
    return init;
  }
\end{minted}
\end{samepage}

The third algorithm in this chapter takes two ranges, given by its iterators, ane reduces the combined elements of the ranges to a single output values.
The default behavior of this algorithms is to perform a classical Euclidean inner-product, \ie to sum up the products of the elements of the two ranges.

Instead of this default operation, one can pass two functors to the algorithm. The first one is the reduction functor (plus by default) and the second one
is the element-combination functor (multiplies by default):
%
\begin{samepage}
\begin{minted}{c++}
  template <class InputIt1, class InputIt2, class T,
            class BinaryOperation1, class BinaryOperation2>
  T inner_product(InputIt1 first1, InputIt1 last1,
                  InputIt2 first2, T value,
                  BinaryOperation1 op1, BinaryOperation2 op2)
  {
    while (first1 != last1) {
      value = op1(value, op2(*first1, *first2));
      ++first1;
      ++first2;
    }
    return value;
  }
\end{minted}
\end{samepage}

\begin{example}
  The following example first generates sequences of increasing values and then calculates the two-norm and the inf-norm as well as
  an inner-product:
  \begin{minted}{c++}
  #include <numeric>
  #include <cmath>
  #include <list>
  #include <vector>

  int main()
  {
    std::list<int> l(10);
    std::vector<int> v(10);

    // generate input data
    std::iota(l.begin(), l.end(), 0); // 0,1,2,3...
    std::iota(v.begin(), v.end(), 1); // 1,2,3,4...

    auto two_norm = std::sqrt( std::accumulate(l.begin(), l.end(), 0,
      [](int erg, int a) { return erg + a*a; }) );

    auto inf_norm = std::accumulate(v.begin(), v.end(), 0,
      [](int erg, int a) { return std::max(erg, a); });

    auto dot = std::inner_product(l.begin(), l.end(), v.begin(), 0,
      [](int a, int b) { return a+b; },
      [](int a, int b) { return a*b; });
  }
  \end{minted}
\end{example}
