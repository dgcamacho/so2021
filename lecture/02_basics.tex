\chapter{C++ Basics\label{sec:basics}}
\section{Introductory example\label{sec:introductory-example}}

Let $x,y\in \mathbb{R}^2$ be two elements of the (Euclidean) vector space $\mathbb{R}^2$, interpreted as
two points (coordinate vectors) in the plane. The space may be equipped with a norm induced by the standard
dot product in $\mathbb{R}^2$.

Implement this vector space and calculate for two elements of the space its distance, \ie the norm of its difference!

So, the structure representing the vector space should hold all possible realizations of vectors in this vector space
and should provide required vector space operations on its realizations (instances).


\begin{minted}[frame=lines,label={Introductory example}]{c++}
  #include <iostream> // for std::cout
  #include <cmath>    // for std::sqrt

  // Structure defining the vector space
  struct Vector
  {
    double x, y;

    Vector operator-(Vector that) const
    {
      return {this->x - that.x, this->y - that.y}; // pointer vs. reference
    }
  };

  double dot(Vector a, Vector b)
  {
    return a.x * b.x + a.y * b.y; // operator precedence!
  }

  double two_norm(Vector a) { return std::sqrt(dot(a,a)); }

  /*
    Distance of two points
    */
  double distance(Vector a, Vector b) { return two_norm(a - b); }

  int main() // or int main(int argc, char** argv)
  {
    Vector a{ 1.0, 2.0 };
    Vector b{ 7.0,-1.5 };
    std::cout << "distance of a and b = " << distance(a,b) << std::endl;
    return 0;
  }
\end{minted}

Some comments about this example:

\begin{itemize}
  \item Main program: The entry point for the program is the function \cpp{main}. It must be available in all executables and returns an
        integer indicating an error code of the program (\cpp{0} means no error).

  \item Typically, there are just two variants of the \cpp{main} function allowed, without arguments or with two arguments containing
        command-line parameters to the program. Thereby, \cpp{int argc} indicates the number of command-line arguments and \cpp{char** argv}
        or \cpp{char* argv[]} a sequence of null-terminated character sequences (strings) representing the actual command-line arguments.
        Especially, the zero-th argument \cpp{argv[0]} corresponds to the name of the executable.

        \textit{Remark:} Some compilers allow more than those two arguments, that may contain environmental variables.
  \item Input- and Output is not part of the C++ core language, but is implemented in libraries, like the C++ standard library. Those libraries
        must be included explicitly.

  \item Include-files are any regular files that can be found by the compiler. Typically, those includes have the file ending \texttt{.h}
        (for header file) and contain specifications of the interface of functions or even implementations of those functions.
        Include in C++ means: the text of the file is copied to the include directive \cpp{#include} into the code.

        \textit{Remark 1:} Header-files of the C++ standard library do not have a file extension. This is, in order to avoid conflicts with the
        C standard library (those files have the extension \texttt{.h}).

        \textit{Remark 2:} There are two variants for the include directive: \cpp{#include <Dateiname>} or \cpp{#include "Dateiname"}. In the
        first variant the include files are search in the compiler include paths and system paths while in variant 2 it is search also in the
        current source directory. This is why the standard library is typically included in angular brackets \cpp{<...>}.

  \item The functions of the standard library are group in the namespace \cpp{std}. Again, this is done in order to avoid conflicts with functions
        from other libraries and your own code. In order to call functions from the standard library, you have to add the prefix
        (name resolution operator) \cpp{::}, \eg \cpp{std::sqrt}.

  \item Additionally to the main program, we have a class (structure) \cpp{Vector} and (free) functions \cpp{dot}, \cpp{two_norm}, and \cpp{distance}.
        A free function is a function not part of a class. But, there is also a function bound to the class. It has the strange name
        \cpp{operator-} and implement the subtraction operator between two vectors.

  \item The class \cpp{Vector} contains 2 member variables, that are filled with values for concrete realizations (instances) of that class in the
        \cpp{main()} function. The access to these values is by the ``member selection''-operator \cpp{.} (point).

  \item Finally, the output of the result to the screen is by an output-stream object \cpp{std::cout} (part of the standard library). It provides
        a way to assign new output data to the output device, using the ``shift'' operator \cpp{<<}. The expression \cpp{std::endl} thereby indicates
        a line-break (the end-of-line symbol). One could also write the character \cpp{'\n'} directly.

  \item Brackets \cpp{{ }} in C++ inclose a local code block (scope). Variables declared inside a scope can only be accessed from within that scope
        or a sub-scope. The brackets are also used during the initialization of an object.

  \item Single line comments are introduced by \cpp{//} and multi-line comments are introduced by \cpp{/* ... */}
\end{itemize}

Some questions to think about:
\begin{itemize}
  \item What happens if you add another \cpp{main(...)} function to the code? Is it possible to add both main functions,
        \cpp{main(), main(int, char**)} at the same time?
  \item There is not just text pushed to the output stream, but also values (numbers). How are numbers printed / converted to strings? How to modify
        this behavior?
  \item What happens if we remove all \cpp{const}s in argument lists? Why is there a \cpp{const} behind a function?
  \item Is it possible to remove the reference sign \cpp{&}? What could be the consequence of this?
\end{itemize}


% =================================================================================================
\section{Compiling C++ code\label{sec:compiling}}
Compared to scripting or interpreted languages, like Python, Matlab, or JavaScript, C++ code must be translated into machine-readable, executable instructions. This process of translation is called \Index{Compiling}. More generally, one could understand compiling as a transformation of code
from one (high-level) language to another (low-level) language.

\begin{rem}
  During the compiling of C++ code, you might even print out intermediate states of is transformation process, like preprocessor output, or
  Assembler output. We will look at these intermediate code in the lecture or exercises, to understand better, what the compiler is doing with
  our code.
\end{rem}

\begin{itemize}
\item The process of compiling is performed by a program, called the \Index{compiler}. Typical examples of compilers are \emph{g++},
      \emph{clang}, \emph{Intel ICC}, \emph{MSVC}, and others.
\item The compiler gets as input a \Index{translation unit}, typically a text file containing the c++ code -- the definition of functions and classes.
      A program typically consists of many translation units that are combined)
\item The output of the compiler is a collection of \Index{object files}, one for each translation unit.
\item To generate an executable (or a library) from these object files, the \Index{linker} combines all the objects to a single file.
\end{itemize}

The process of compiling can be split into several stages:
\begin{description}
  \item[pre-processing] (performed by the \Index{preprocessor}) The content of include files is copied to the include directives, macros and
  preprocessor constants are evaluated.
  \item[linguistic analysis] Check of syntax rules.
  \item[\Index{assembling}] Translation of the language constructs into CPU instructions, \eg in form of assembler code.
  \item[code output] Transformation of internal code (assembler code) into machine-readable binary code. Collection of symbols into
  symbol table with jump references.
\end{description}

On many linux distributions the c++ compiler of the GNU Compiler Collection (GCC) or the clang compiler of LLVM are preinstalled.
Assume the code from the introductory example is stored in a text file \texttt{distance.cc}. This can be compiled into an executable, by
%
\begin{verbatim}
  c++ distance.cpp
\end{verbatim}
%
where \texttt{c++} is an alias (often a symbolic link) to the actual compiler.

\begin{rem}
  The version and name of the compiler can be obtained by \texttt{c++ --version}.
\end{rem}

The result of the compilation is a binary file, named \texttt{a.out}. This is the default executable name, that can be changed by
providing the argument \texttt{-o NAME}:
%
\begin{verbatim}
  g++ distance.cpp -o distance
\end{verbatim}
%
Later in the lecture we get to know different C++ language features available in a specific version of the C++ standard (see history of C++).
The standard can be selected explicitly by the additional argument \texttt{-std=VERSION}, \eg for \cxx{11}:
%
\begin{verbatim}
  g++ -std=c++11 distance.cpp -o distance
\end{verbatim}
%
where the \texttt{VERSION} follows the naming given in the chapter \emph{History of C++}.

If you have multiple files to compile, \eg one file provides the implementation of the functions and classes, and the other file just
the \cpp{main()} function, we say that we have multiple translation units. Those can be compiled individually and then linked together:
%
\begin{verbatim}
  g++ -c file1.cpp
  g++ -c file2.cpp
  g++ file1.o file.o -o program
\end{verbatim}
%
The output name of the compiled translation units follows the pattern \texttt{FILE\_BASE\_NAME.o}. The compiler allows to combine the compiler
and linker call in one line, by listing all the files to compiler one after the other:
%
\begin{verbatim}
  g++ file1.cpp file2.cpp -o program
\end{verbatim}

If a source file depends on some include files (in the top of the file you find the lines \cpp{#include <...>} or \cpp{#include "..."}), the
compiler has to search for these \textit{header}-files. It automatically searches in default system paths, but for everything else the compiler
has to be pointed to the location of the include files. This can be done by the additional argument \texttt{-I[path-to-files]}, \eg
%
\begin{verbatim}
  g++ -I/usr/local/library/include/ file1.cpp file2.cpp -o program
\end{verbatim}
%
and if the program depends not only on include files, but also \Index{Symbols} (compiled implementations) of library functions, a list of additional
library to link the executable with has to be appended. Therefore, two arguments are allowed for the compiler: \texttt{-L[path-to-library]} and
\texttt{-l[libname]}, where \texttt{libname} contains the part of the file name of the library between the prefix \texttt{lib} and the file
extension \texttt{.so} or \texttt{.a}. (This might be different on different operating systems, like MacOS or MS Windows).
%
\begin{verbatim}
  g++ -I/usr/local/library/include/ file1.cpp file2.cpp -o program -L/usr/local/library/lib -llibrary
\end{verbatim}
%

If your project depends on multiple library that itself depend on other libraries it gets more and more complicated to put everything correctly
into the compile command. To simplify this, there are multiple different \Index{build systems} developed that collect and analyze dependencies
and generate compiler commands for you. A classical one is a \Index{Makefile}, that defines various targets that can depend on each other and
some way to construct from these targets a sequence of commands to execute in order to compile (build) the executable. Another example is
\Index{CMake} (more precisely it is a build system generator).

\begin{rem}
As you may have noticed, source files that are compiled by the compiler are typically named with a file extension \texttt{.cc}, \texttt{.cpp},
or \texttt{.cxx}. This differs from the include (header) files with file extension \texttt{.h}, \texttt{.hh}, \texttt{.hpp}, or \texttt{.hxx}.
Here the first file extension comes from C and is just a abbreviation for \textit{header}. Later in the lecture, we will see source (implementation)
files, that are not compiled, but are typically included at the end of the corresponding header file. This is related to template
implementations. Sometimes these files are name \texttt{.tpp}, or \texttt{.txx}, but more ofter just \texttt{.impl.hh}, or \texttt{.inc.hh},
(with any of the header file extensions from above).

While file extensions and naming of files in general is arbitrary, it is recommended to name source and its corresponding header file with the
same base name and matching file extensions, \eg \texttt{linear\_algebra.hh} and \texttt{linear\_algebra.cc}.
\end{rem}


% ==============================================================================
\section{Basic structure of a C++ program\label{sec:code-structure}}
Each C++ code resulting in an executable, must contain exactly one \cpp{main(...)} function, while both variants
%
\begin{minted}{c++}
  int main();
  int main(int argc, char* argv[]); // or. int main(int argc, char** argv);
\end{minted}
%
are allowed. The arguments \cpp{argc, argv} are filled when running the executable with command-line arguments. Thereby, the argument \cpp{argc}
represents the number of command-line arguments and \cpp{argv} represents and \textit{array} of \textit{strings} representing each individual
command-line argument. The fist entry in this array, \cpp{argv[0]}, contains the name of the executed program.

\paragraph{Splitting in multiple source files}
Code can (and should) be split into multiple translation units representing different components of the program. This splitting means multiple
header and source files, where each source file can be translated into an object file without the knowledge of the other source files.

Typically, in header files the functions and classes are just \Index{declared}, while in the source file those entities are \Index{defined}.

Example 1: A header file contains the \Index{prototyp} (interface description) of a function and a class definiton.
\begin{minted}[frame=lines,label={example.hh}]{c++}
#ifndef EXAMPLE_HH
#define EXAMPLE_HH

// declaration and definition of a class
struct Point
{
  double x, y;

  // declaration of a member function
  Point subtract(Point other) const;
};

// declaration of a function
double distance(Point a, Point b);

// declaration of a template function
template <class T> void foo();

#include "example.impl.hh"
#endif // EXAMPLE_HH
\end{minted}

Example 2: The definition of a template function (included at the end of the header file)

\begin{minted}[frame=lines,label={example.impl.hh}]{c++}
#pragma once
// definition of the funktion foo()
template <class T>
void foo() { /*...*/ }
\end{minted}

Example 3: The source file, includes the header file and defines the functions

\begin{minted}[frame=lines,label={example.cc}]{c++}
#include "example.hh"
#include <cmath>

// definition of a member function
Point Point::subtract(Point other) const
{
  return {this->x - other.x, this->y - other.y};
}

// definition of the function distance()
double distance(Point a, Point b)
{
  Point ab = a.subtract(b);
  return std::sqrt(ab.x * ab.x + ab.y * ab.y);
}

int main(int argc, char** argv)
{
  Point a{ 1.0, 2.0 }, b{ 7.0,-1.5 };
  distance(a,b);
  return 0;
}
\end{minted}


Some remarks to the examples above:
\begin{itemize}
  \item The triplet \cpp{#ifndef NAME}, \cpp{#define NAME} and \cpp{#endif} builds a so called \textbf{include guard}. It prevents the header file
    to be included multiple times in the same translation unit. This is not allowed, since the C++ standard requires a \textbf{one definition rule},
    meaning: No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.

    Another way of enforcing that a file is included only once, is by using the (non-standard) preprocessor directive \cpp{#pragma once} in the
    top of the include file. This directive is supported by all major compilers and can be used without any problems.

  \item If you want to (or have to) provide an implementation of a function or class method in a header file, it must be included together with
    the corresponding declaration. Often, since is done my an include statement at the end of the header file. Or the definition is provided
    together with the declaration.
\end{itemize}


% ==============================================================================
\section{Variable declaration and fundamental types\label{sec:data-type}}
C++ is a statically typed language (in contrast to dynamically typed languages like \eg PHP), meaning: each identifier and expression in a
C++ program has assigned a type that is already known to the compiler and this type can not be changed.

Examples:
\begin{minted}{c++}
  float x;          // x is a single precision floating point number
  int y = 3+4;      // y is an integer variable with initial value 7
  float f(int);     // f is a function with one integer argument and float return type
\end{minted}

Here, the variable \cpp{y} is initialized with an expression on the right-hand side of the assignment operator \cpp{=}. This
expression \cpp{3+4} also has a type. Since \cpp{3} and \cpp{4} are integer numbers and the result of the addition of two integers is
defined to be also an integer, the expression is of type \cpp{int}.

\begin{standard}{\S 7.1 (1)}
  An expression is a sequence of operators and operands that specifies a computation. An expression can result in a value and can cause side effects.
\end{standard}

\begin{rem}
  That the expression \cpp{3+4} has the type \cpp{int} is not as trivial as you might think. In some languages, it might be a type that could be
  larger than \cpp{int} but that can hold the value of the addition of these two integers.
\end{rem}


% -------------------------------------------------------------------------------------------------
\subsection{Automatic type deduction}
When the compiler parses an expression, it internally determines its type. In order to create a variable of just that type, the language has
introduced the meta-type \cpp{auto}. It is not an actual data-type, but is a placeholder for the type determined by the expression of the
initialization:
\begin{minted}{c++}
  auto x = 3+4;       // deduce the type from the expression: x <-- int
  auto y = long{3+4}; // explicitly committing to a type: y <-- long
  auto z{3+4};        // same as variable x: z <-- int                  [C++17]
\end{minted}

% -------------------------------------------------------------------------------------------------
\subsection{Literals\label{sec:literal}}
A literal is a tokes directly representing a constant value of a concrete type.

Examples:
\begin{minted}{c++}
  42u       // unsigned integer literal
  108.87e-1 // floating point literal
  true      // boolean literal
  "Hello"   // string literal
\end{minted}

The type of the literal is often determined by a literal suffix (like in \cpp{42u} the \texttt{u}). All integer literals are just a
sequence of digits that has no period or exponent part, while floating point literals must contain a period and/or an exponent part.
Character literals are introduced with a single quote \cpp{'c'}, and string literals with the double quotes \cpp{"Hello"}. There are
some more literals, we will see in the exercise.

\begin{rem}
  Since\marginpar{[\cxx11]} \cxx{11} one can define own literals of the form \texttt{build-in literal + \_ + Suffix}. This allows, for example, to create
  numbers with units.

Example:
\begin{minted}{c++}
  101000101_b  // binary representation
  63_s         // seconds
  123.45_km    // kilometer
  33_cent      // cent
\end{minted}

where the implementer is responsible for giving those literals a meaning.
\end{rem}

\begin{rem}
  A literal is a \textit{primary expression}. Its type depends on its form (see above). A string literal is an \Index{lvalue}; all other
  literals are \Index{prvalues}.
\end{rem}


% -------------------------------------------------------------------------------------------------
\subsection{Declaration -- Definition -- Initialization}
\begin{description}
\item[Declaration] A declaration may introduce one or more names into a translation unit or redeclare names
  introduced by previous declarations.

\item[Definition] A \textit{declaration} that provides the implementation details of that entity, or in case of variables, reserves memory for
  the entity.

  A \textit{declaration} of a class (\cpp{struct}, \cpp{class}, \cpp{enum}, \cpp{union}), function, or method is a definition if the declaration is
  followed by curly braces, containing the implementation body.

  Variable declarations are always \textit{definitions} unless prefixed with the keyword \cpp{extern}.

\item[Initialization] A \textit{definition} with explicit value assignment.
\end{description}

Examples:
\begin{minted}{c++}
  class Test;             // declaration of a class
  class Test {};          // definition of that class

  int func();             // declaration of a function
  int func() { return 7;} // definition of that function

  extern int i=func();    // definition and initialization of a variable
  extern int j;           // declaration of a variable
  int k;                  // definition of a variable

  Test obj();             // declaration of a funktion (with return type Test)
\end{minted}

A fundamental rule is that you are not allowed two define an object twice. While it may be allowed to declare exactly the same object multiple times, even after the definition.

\begin{standard}{\S 6.3 (1)}
  \textbf{One-definition rule:} No translation unit shall contain more than one definition of any variable, function, class type, enumeration
  type, or template.
\end{standard}

% -------------------------------------------------------------------------------------------------
\subsection{Fundamental Types\label{sec:fundamental-type}}
We have seen already some types in the examples above, like integer types and floating-point types. There are more fundamental data-types
available in C++. A summary can be found at \url{http://en.cppreference.com/w/cpp/language/types}.

Basic types in C++ a categorized into three groups: integral types, floating-point types, and \cpp{void}. Integral type represent integer numbers, while floating-point type might represent fractions.

The type \cpp{void} represents the empty set of values. No variable can be declared of type \cpp{void}. Thus, \cpp{void} is an \emph{incomplete type}. It is used as the return type for functions that do not return a value. Any expression can be explicitly converted to type \cpp{void}.

\subsubsection{Integral numbers}
The group of integral types contains
\begin{itemize}
  \item The boolean type \cpp{bool} with values \cpp{true} and \cpp{false} (both are boolean literals). The size of that type is implementation
  defined and typically $> 1$ Byte.
  \item Character type \cpp{char} to represent a single character. It is a distinct type and either a signed or unsigned integer type of size $\geq$ 1 Byte. For utf-8 character encodings, there are also larger character types like \cpp{wchar_t}, \cpp{char16_t}, or \cpp{char32_t}.
  \item Standard (signed/unsigned) integer types include \cpp{short int, int, long int, long long int} possibly qualified with the type prefix
  \cpp{signed, unsigned}. No signed-ness qualification means signed integers. The postfix \cpp{int} may be omitted (except for \cpp{int} itself).

  The range of representable values for a signed integer type is $-2^{N-1}$ to $2^{N-1} - 1$ (inclusive), where $N$ is called the width of the type.
  An unsigned integer type has the same width $N$ as the corresponding signed integer type. The range of representable values for the unsigned type
  is $0$ to $2^{N-1}$ (inclusive).

  Arithmetic for the unsigned type is performed modulo $2^N$. \emph{Note:} Unsigned arithmetic does not overflow. Overflow for signed arithmetic
  yields \textbf{undefined behavior}.
\end{itemize}

In the C++ standard the sizes (widths) of the integer types are not specified explicitly, but a minimal size is given. Thus, one finds the relations
%
\cppline{  sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)}
%
where \cpp{sizeof} is a C++-operator returning the width of a data-type (or an expression) in Byte. On 32-Bit systems, typically the sizes 2, 4, 4, 8 Byte are used, on 64 Bit systems \cpp{long} is often of size 8 Byte.

The\marginpar{[\cxx{11}]} type \cpp{long long} is introduced in \cxx{11} and was available as compiler specific extensions before.

\begin{rem}
  As\marginpar{[\cxx{11}]} for \cpp{char} there are integer type with prescribed width, defined in the header file \cpp{<cstdint>}. Those are named \cpp{std::int16_t, std::uint32_t, ...}.
\end{rem}

\begin{rem}
  In the standard library a \textbf{type-alias} is introduced for an integer type often used for vector indices and vector sizes,
  named \cpp{std::size_t}. It is typically an \cpp{unsigned long int} type, but on some compilers it may be different. The type referenced
  by \cpp{std::size_t} can store the maximum size of a theoretically possible object of any type (including array).
\end{rem}

There are special \emph{literals}, suffixes appended to numbers, to indicate explicitly a type: \texttt{U, u, L, l, LL, ll}, where
there is no difference between lower and upper case suffixes. \texttt{u} means \cpp{unsigned}, \texttt{l} means \cpp{long}, and \texttt{ll} means
\cpp{long long}. Additionally, a prefix can be put in front of the number to indicate a base for the number systems used: \texttt{0} (Null), \texttt{0x}, or \texttt{0b}. Those represent octal, hexadecimal, or binary numbers, repsectively.

Example:
\cppline{  1234L, 9565ul, 012 == 10, 0x2a == 42}

\begin{standard}{\S 5.13.2 (1)}
  An integer literal is a sequence of digits that has no period or exponent part, with optional separating single
  quotes that are ignored when determining its value. An integer literal may have a prefix that specifies
  its base and a suffix that specifies its type.
\end{standard}


\subsubsection{Floating-point types}
Standard type for floating-point numbers are
%
\cppline{  float, double, long double}
%
The range of possible values is defined in \cpp{<limits>} and the sizes may be compiler dependent, typically 4, 8, 10 Byte. The relation
%
\cppline{  sizeof(float) <= sizeof(double) <= sizeof(long double)}
%
holds for the floating-point types.

Literals, to indicate how to interpret a number, are \texttt{F,f,L,l} for \cpp{float} and \cpp{long double}.

\begin{rem}
  In GCC an extension is implemented to allow quad-precision arithmetics with the data-type \cpp{__float128}. The size is 16 Byte. Typically, this
  is implemented as a software library, \eg by concatenating two \cpp{double} types. Only rarely there is hardware support for quad precision
  numbers (\eg IBM POWER9 CPU). The arithmetic is defined in the standard document \href{https://doi.org/10.1109%2FIEEESTD.2008.4610935}{IEEE 754-2008}.
\end{rem}

\begin{rem}
  To do arithmetic with arbitrary precision, there a multiple libraries available. Examples include \href{https://gmplib.org/}{GNU GMP}
  (Gnu MultiPrecision Arithmetic Library) and \href{https://www.boost.org/doc/libs/1_71_0/libs/multiprecision/doc/html/index.html}{Boost.Multiprecision} library.

  An example of high precision calculation of the enclosed area of a circle with boost multiprecision is given below. Note, it uses templates to
  implement the actual algorithm.
\end{rem}
\begin{minted}[frame=lines,label={multiprecision.cc}]{c++}
#include <iostream>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/math/constants/constants.hpp>

// Type-alias for floating-point numbers with 50 decimal digits precision and int32_t to represent the exponent
using float_50 = boost::multiprecision::cpp_dec_float_50;

template <class T>
T area_of_a_circle(T r)
{
   using boost::math::constants::pi;
   return pi<T>() * r * r;
}

template <class T>
int digits() { return std::numeric_limits<T>::digits10; }

int main()
{
  float r_f = float(123) / 100;
  float a_f = area_of_a_circle(r_f);

  double r_d = double(123) / 100;
  double a_d = area_of_a_circle(r_d);

  float_50 r_mp = float_50(123) / 100;
  float_50 a_mp = area_of_a_circle(r_mp);

  // 4.75292
  std::cout << std::setprecision(digits<float>()) << a_f << std::endl;
  // 4.752915525616
  std::cout << std::setprecision(digits<double>()) << a_d << std::endl;
  // 4.7529155256159981904701331745635599135018975843146
  std::cout << std::setprecision(digits<float_50>()) << a_mp << std::endl;
}
\end{minted}


\begin{rem}
  Arithmetic with floating-point number is not the same as arithmetic with real $\mathbb{R}$ numbers. There are effects of rounding,
  finite representation, cancellation, non-associativity, $\ldots$. Details can be found in the standard document
  \href{https://standards.ieee.org/content/ieee-standards/en/standard/754-2019.html}{IEEE 754} and are explained in the lecture
  \emph{Computer Arithmetics} by Prof. W. Walter.
\end{rem}


\begin{guideline}{Principle}
  Declare variables as late as possible, usually right before using them the first time and whenever possible not before you can initialize them.
\end{guideline}



\subsection{Number conversion}
Whenever you initialize a variable with an expression, the value of that expression must be converted to the type of the variable.

Example:
\begin{minted}{c++}
  long l = 1234567890123;
\end{minted}
(Fine if \cpp{long} is 64Bit long, wrong value if \cpp{long} is only 32Bit long)

We call an initialization of a value to a smaller type that can not represent this value a \emph{narrowing initialization} or
\emph{narrowing conversion}. In the example above, the compiler will not give any error and compiles fine, although the value might be wrong.
Maybe the compiler prints a warning, but not on all warning levels and this is not guaranteed.

\begin{guideline}{Principle}
  Enable all warnings and stick to the c++ standard, \ie use the compiler flags \texttt{-Wall -Wextra -pedantic}, optionally you may
  even set the flag \texttt{-Werror} to assert an error instead of warnings.
\end{guideline}

With\marginpar{[\cxx{11}]} \cxx{11} the compiler added the \emph{uniform initialization} using curly brackets, in order to raise an error
instead of silently accepting the code, in case of narrowing conversion. This means, almost always use
\begin{minted}{c++}
  long l1{1234567890123}; // or
  long l2 = {1234567890123};
\end{minted}

Some examples of narrowing conversions:
\begin{minted}{c++}
  int i1 = 3.14;    // initializes to 3, no error
  int i2 = {3.14};  // Narrowing ERROR: fractional part lost

  unsigned u1 = -3; // initializes to largest possible unsigned number
  unsigned u2{-3};  // Narrowing ERROR: no negative values

  float f1 = {3.14} // ok. initializes to float number closest to 3.14

  double d = 3.14;
  float f2 = {d};   // Narrowing ERROR. Possible lost of accuracy

  unsigned u3 = {3};
  int      i3 = {2};
  unsigned u4 = {i2}; // Narrowing ERROR: no negative values
  int      i4 = {u3}; // Narrowing ERROR: no all values
\end{minted}

\begin{rem}
  The\marginpar{[\cxx{17}]} curly braces, \ie uniform initialization, also works with the automatic type deduction \cpp{auto}. But be careful! The meaning
  of the curly braces has changed in \cxx{17} and also before results sometimes in a type different from what you would expect.
  \begin{minted}{c++}
  auto x1 = {42}; // c++14 x1 is of type std::initializer_list<int>
  auto x2 = {42}; // c++17 x2 is of type std::initializer_list<int>

  auto x3{42};    // c++14: x3 is of type std::initializer_list<int>
  auto x4{42};    // c++17: x4 is of type int
  \end{minted}
\end{rem}

\begin{defn}
  For floating point values we call a conversion to a smaller data type (\eg \cpp{double -> float}) a \emph{floating-point conversion} (with possibly loss of precision) and otherwise a \emph{floating-point promotion} (represent the value exactly with the larger type).
\end{defn}

\begin{rem}
  Note, in floating-point conversion, if a value of \cpp{T1 > T2} is between two floating point number of \cpp{T2}, the rounding to a one of the both values is implementation defined and might be controlled with some intrindic functions. If the value is out of range of \cpp{T2} the behavior is undefined.
\end{rem}

\subsection{Constants\label{sec:const}}
An important aspect of programming languages is to control the access to data. A data-type with the property \cpp{const}
is called a \emph{constant} ans is immutable. The syntax to declare a constant is

\cppline{TYPE const VARNAME = VALUE;}

The \cpp{const} could also be on the left of the \texttt{TYPE}, but as a rule of thumb put the qualifier \cpp{const} on the right of what
should be constant. The compiler will assert an error if you try to modify a constant object.

Example:
\begin{minted}{c++}
  int n1 = 0;           // non-const object
  int const n2 = 0;     // const object
  const int n3 = 0;     // const object (same as n2)

  n1 = 1;  // OK: mutable object
  n2 = 2;  // ERROR: non-mutable object
\end{minted}

Constants can be defined using automatic type deduction. Therefore, the keyword \cpp{const} simply qualifies the placeholder \cpp{auto}:
%
\begin{minted}{c++}
  auto i1 = 7;          // mutable variable
  auto const i2 = 8;    // const integer variable initialized with 8
  const auto d1 = 2.0;  // const double variable initialized with 2.0
\end{minted}

\subsubsection{constexpr specifier}
There is another qualifier that is stronger that \cpp{const}: The \cpp{constexpr} specifier declares that it is possible to evaluate the
value of the variable at compile time. Such variables can then be used where only compile time constant expressions are allowed.
A \cpp{constexpr} specifier used in an object declaration implies \cpp{const}.

A \cpp{constexpr} variable must satisfy the following requirements:
\begin{itemize}
  \item its type must be a \emph{LiteralType}.
  \item it must be immediately initialized
  \item the full-expression of its initialization, including all implicit conversions, constructors calls, etc, must be a constant expression
\end{itemize}

The category \emph{LiteralType} can not yet be fully explained, but especially the fundamental types discussed above are \emph{LiteralTypes}.

\begin{rem}
  \cpp{constexpr} variables, expressions and functions are a powerful tool within C++, available since \cxx{11} and extended in \cxx{14} and \cxx{17}.
  In the chapter \emph{Meta programming}, we will see how to use \cpp{constexpr} (functions) as a language within C++ to force the compiler to
  do computations for us.
\end{rem}


% -------------------------------------------------------------------------------------------------
\subsection{Scopes}
Each name that appears in a C++ program is only valid in some possibly discontiguous portion of the source code called its scope. Thus,
scopes determine the lifetime and visibility of (non-static) variables and constants. There are different types of scopes,
global scope, function scope, class scope, block scope, function parameter scope, namespace scope, \dots. Typically, scopes a blocks of
code surrounded by curly braces, except for the global scope that lives outside of functions and classes.

\begin{guideline}{Principle}
  Do not use global variables!
\end{guideline}

A local variable is declared within a block of a function. Its visibility and accessability is limited to the \texttt{\{ - \}}-enclosed block
of its declaration. More precisely, the scope of the variable begins at the point of declaration and ends at the end of the block.
\begin{minted}{c++}
  int main()
  {                     // begin of the function block
    double pi = 3.14;   // begin of the variable scope
    std::cout << pi;
  }                     // end of variable scope and function block
\end{minted}

There might be nested blocks within other blocks that can limit the visibility of names declared inside this block:
\begin{minted}{c++}
  int main()
  {                     // begin of the function block
    {                   // begin of an inner block scope
      double pi = 3.14; // begin of the variable scope
    }                   // end of variable and block scope
    std::cout << pi;    // ERROR: pi is out of scope
  }                     // end of variable scope and function block
\end{minted}

\subsubsection{Hiding}
In each scope a name can be defined only once (one-definition rule), but in another scope (even nested) the same name can be
used to declare a new variable hiding the outer one with lifetime only in that nested scope.

\begin{minted}[frame=lines,label={scope.cc}]{c++}
  int x = 11;  // (0) global variable x

  void f() {   // function scope
    int x;     // (1) local x hiding global x
    x = 1;     // assignment to local x (1)
    {
      int x;   // (2) hides local x (1)
      x = 2;   // assignment ot local x (2)
    }
    x = 3;     // assignment to local x (1)
  }

  void f2() {  // function scope
    int y = x; // use global x
    int x = 1; // (3) hides the global x
    ::x = 2;   // assignment to global x
    y = x;     // use local x (3)
    x = 2;     // assignment to local x (3)
  }
\end{minted}


% =================================================================================================
\section{Library types}
With the fundamental types and some language constructs we will learn later, you can already build powerful C++ programs. But it is possible
to define your own types for more complex data-structures, like vectors, tuples, lists, associative maps and sets, and so on. The standard library
defines already some of these types thus allows to easily write more advanced programs.

Here, I just give an overview about some useful data-structures, later we will look more deeply into the standard library.

% -------------------------------------------------------------------------------------------------
\subsection{Strings}
Character sequences were already mentioned at the beginning, when discussing the argument the function \cpp{main(int, char**)}. This
functions accepts a low-level form of arrays of strings as second argument. But these low-level strings are hard to use right. Thus,
the standard library defines the type \cpp{std::string} instead:
\begin{minted}{c++}
  #include <iostream> // for std::cout, std::endl
  #include <string>
  int main()
  {
    std::string text = "This is a long text";
    std::cout << "length = " << text.size() << std::endl;
  }
\end{minted}

% -------------------------------------------------------------------------------------------------
\subsection{Container}
\subsubsection{Sequence Container}
In the header \cpp{<vector>} the standard library provides a contiguous resizable vector container with flexible element types:
\begin{minted}{c++}
  #include <vector>
  int main()
  {
    // vector of 3 doubles
    std::vector<double> x(3);
    x[0] = 0.0; x[1] = 1.0; x[2] = 2.0;

    // direct initialization with values
    std::vector<double> y = {1.0, 2.0, 3.0};

    // add a new entry at the end of the vector
    x.push_back(3.0);

    // resize the vector to the specified size
    y.resize(4);

    assert(x.size() == y.size());
  }
\end{minted}

The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using \cpp{capacity()} function.

\begin{rem}
  The \cpp{main()} function needs two argument to represent an array of string, the size and the address. Instead, one could
  store this in a vector of strings:
  \begin{minted}{c++}
  int main(int argc, char** argv) {
    std::vector<std::string> args(argv, argv + argc);
    // nr of arguments = args.size()
    // i-th argument = args[i]
  }
  \end{minted}
\end{rem}

\subsubsection{Associative Container}
Apart from the \emph{sequence container} \cpp{std::vector}, there is also the associative container \cpp{std::map}, associating a value to a key:
\begin{minted}{c++}
  #include <map>
  int main()
  {
    std::map<int, double> m; // mapping int -> double
    m[17] = 42.0             // new association is created on access

    // test whether the key 42 is found
    assert(m.count(42) == 1);
  }
\end{minted}

This can be combined with vector and string:
\begin{minted}{c++}
  #include <map>
  #include <string>
  #include <vector>
  int main()
  {
    std::map<std::string, std::vector<int>> m; // mapping string -> vector<int>
    m["Hello"] = {1,2,3,4,5};
  }
\end{minted}

\begin{rem}
  Note that maps need more memory and the access is much slower than for a vector. So, if you have an integer key and know the min and max index, prefer a vector over a map, or just use the map as intermediate container to build up the container.
\end{rem}

\subsection{Iterating over container}
All standard containers can be traversed using range-base for loops
\begin{minted}{c++}
  #include <map>
  #include <string>
  #include <vector>
  int main()
  {
    std::map<int, double> m; // fill up the map
    std::vector<double> v; // fill up the vector

    for (auto i : m)
      std::cout << i.first << ", " << i.second << std::endl; // (key, value) pair, see below

    for (double d : v)
      std::cout << d << std::endl;
  }
\end{minted}
If you don't know the type of the elements in traversal or it is complicated to write (like for \cpp{std::map}), use (qualified) \cpp{auto} instead.

% -------------------------------------------------------------------------------------------------
\subsection{Tuples}
A vector represents a tuple of values of the same type. If the type should be
different for each element, one could use a \cpp{std::tuple} instead. There, the types of all elements must be given
explicitly:
%
\begin{minted}{c++}
  std::tuple<int,double,float> t = {1, 2.0, 3.0f};
\end{minted}
%
To access an entry in a tuple, one cannot use the classical bracket operator \texttt{[]} as for vectors, but has to call a
function instead:
%
\begin{minted}{c++}
  double t1 = std::get<1>(t);
\end{minted}

A special tuple is a pair. It consists of just two elements:
%
\begin{minted}{c++}
  std::pair<int,double> p = {1, 2.0};
\end{minted}
%
Here, the elements can be accessed again using \cpp{std::get}, but have also an explicit name:
%
\begin{minted}{c++}
  int p0 = p.first;
  double p1 = p.second;
\end{minted}

Tuples can be used to return multiple values from a function (see below) and to assign multiple values to a set of
variables:
%
\begin{minted}{c++}
  // create a tuple from values
  auto t = std::make_tuple(0, 1.0, 2.0f);

  // assign the tuple entries to variables
  int t0;
  double t1;
  float t2; // not used
  std::tie(t0,t1,std::ignore) = t;
\end{minted}
%
where \cpp{std::ignore} is an object of unspecified type such that any value can be assigned to it with no effect, and
\cpp{std::tie} is a function that takes references to variables and assigns the value of a tuple to it.


\subsubsection{Structured Binding}
We have seen the effect of \cpp{std::tie} in the last section. There, we had to declare the variables before we can assign
values to it and we have to know the types explicitly. With\marginpar{[\cxx{17}]} \cxx{17} this can be combined with \cpp{auto}
to create new variables with types deduced from the tuple elements. This is called \Index{structured binding}:
%
\begin{minted}{c++}
  auto [t0,t1,t2] = t;
\end{minted}
%
Again, as for classical \cpp{auto} type deduction, the variable declaration can be extended by the const
qualifiers:
%
\begin{minted}{c++}
  auto const [t0,t1,t2] = t;
\end{minted}


This structured binding does not only work for tuple-like structures, but also for structs:
%
\begin{minted}{c++}
  std::pair<int, std::string> p {1, "pair"};
  auto [first,second] = p;
  assert(first == p.first && second == p.second);

  Point point {0.0, 4.0};
  auto [x,y] = point;
  assert(x == point.x && y == point.y);
\end{minted}

\begin{rem}
Tuples (and pairs) can not be traversed like other containers. The reason is that each element in a tuple has a different type and in a loop the elements must have the same type in each iteration. Currently the standard committee discusses and extended version of a loop, like \cpp{for...(auto t : tuple)} or \cpp{for constexpr(auto t : tuple)}. But this is not yet decided. We will see later in the chaper about meta-programming how to write a loop over tuples yourself. Then you get something like
\begin{minted}{c++}
  forEach(tuple, [](auto t) {
    std::cout << t << std::endl;
  });
\end{minted}
that looks quite similar to a regular loop but works with tuples and pairs and many more.
\end{rem}
